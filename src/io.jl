# io.jl
# This module contains the two functions required to read vtk files and
# retrieve coordinate data from them

module IO

include("geometry.jl")

using .Geometry: convert_to_cylindrical

export read_vtk_file, retrieve_coordinates, extract_points, get_mesh_bounds, split_data, match_split_data


"""
    median(v::AbstractVector)

Computes the median of the input vector. For an even number of elements, the median is defined
as the average of the two middle values.

# Arguments
- `v::AbstractVector`: A vector of numeric values.

# Returns
The median of the vector.

# Raises
- `ArgumentError` if the input vector is empty.
"""
function median(v::AbstractVector)
    n = length(v)
    if n == 0
        throw(ArgumentError("Cannot compute median of an empty vector"))
    end
    # Copy the vector so that the original data is not mutated.
    v_sorted = copy(v)
    sort!(v_sorted)
    mid = div(n, 2)
    if isodd(n)
        return v_sorted[mid+1]
    else
        return (v_sorted[mid] + v_sorted[mid+1]) / 2
    end
end


"""
    read_vtk_file(file::String)

Reads a legacy VTK file (POLYDATA, ASCII) and extracts point coordinates and any point data 
(only SCALARS or FIELD sections). Everything else between `POINTS` and `POINT_DATA` is ignored.

# Arguments
- `file::String`: Path to the `.vtk` file.

# Returns
A dictionary containing:
- `:points`: N×3 matrix of point coordinates.
- `:point_data`: Dictionary of attributes (e.g. scalars, fields) associated with each point.

# Raises
- `ArgumentError`: If the file does not exist, if it's not ASCII/POLYDATA, 
  or if the data sections are invalid.
"""
function read_vtk_file(file::String)
    # Quick check on file existence
    if !isfile(file)
        throw(ArgumentError("The file '$file' does not exist. Please provide a valid path."))
    end

    # We'll store points as a flat Float64 array before reshaping
    points_accum = Float64[]
    point_data = Dict{Symbol,Any}()

    # Keep track of whether we're inside POINT_DATA
    in_point_data = false
    expected_point_data_count = 0

    # For reading FIELD data
    fields_to_read = 0
    remaining_field_components = 0
    current_field_name = nothing
    current_field_components = 0
    current_field_points = 0
    current_field_values = Float64[]

    open(file, "r") do io
        # --- Header lines ---
        header_line1 = readline(io)  # e.g. "# vtk DataFile Version 5.1"
        header_line2 = readline(io)  # e.g. "Generated by X"
        format_line  = strip(readline(io))  # "ASCII" or "BINARY"
        dataset_line = strip(readline(io))  # e.g. "DATASET POLYDATA"

        # Check format
        if format_line != "ASCII"
            throw(ArgumentError("Only ASCII format is supported. Found '$format_line' instead."))
        end
        ds_split = split(dataset_line)
        if length(ds_split) < 2 || ds_split[1] != "DATASET" || ds_split[2] != "POLYDATA"
            throw(ArgumentError("Only 'DATASET POLYDATA' is supported. Found '$dataset_line' instead."))
        end

        # --- Step 1: read POINTS section ---
        # We search for a line beginning with "POINTS"
        num_points = 0
        points_parsed = false
        while !eof(io) && !points_parsed
            line = strip(readline(io))
            if isempty(line)
                continue
            end

            # If we find "POINTS", parse its values
            if startswith(line, "POINTS")
                parts = split(line)
                if length(parts) < 3
                    throw(ArgumentError("Invalid 'POINTS' line: '$line'"))
                end
                num_points = parse(Int, parts[2])
                # e.g. "float" or "double" is parts[3], ignored here

                total_needed = 3 * num_points
                while length(points_accum) < total_needed
                    if eof(io)
                        println("Error in file: $file")
                        throw(ArgumentError("Unexpected end of file while reading POINTS data."))
                    end
                    coords_line = strip(readline(io))
                    if isempty(coords_line)
                        continue
                    end
                    coords = split(coords_line)
                    for c in coords
                        val = tryparse(Float64, c)
                        if val === nothing
                            println("Error in file: $file")
                            throw(ArgumentError("Invalid numeric value in POINTS section: '$c'"))
                        end
                        push!(points_accum, val)
                    end
                end

                # We've parsed the correct number of coordinates, set a flag
                points_parsed = true
            end
        end

        if length(points_accum) != 3 * num_points
            throw(ArgumentError("Number of coordinate values read does not match '3 * num_points'."))
        end

        # --- Step 2: ignore lines until we hit "POINT_DATA" ---
        while !eof(io)
            # Peek at the line without losing it
            pos = position(io)
            line = strip(readline(io))
            if startswith(line, "POINT_DATA")
                # Seek back so we can reprocess properly
                seek(io, pos)
                break
            end
        end

        # --- Step 3: read POINT_DATA ---
        while !eof(io)
            line = strip(readline(io))
            if isempty(line)
                continue
            end

            # Found POINT_DATA
            if startswith(line, "POINT_DATA")
                parts = split(line)
                if length(parts) < 2
                    throw(ArgumentError("Malformed 'POINT_DATA' line: '$line'"))
                end
                in_point_data = true
                expected_point_data_count = parse(Int, parts[2])  # Corrected index

            # --- SCALARS blocks ---
            elseif in_point_data && startswith(line, "SCALARS")
                scalars_split = split(line)
                if length(scalars_split) < 3
                    throw(ArgumentError("Invalid SCALARS definition: '$line'"))
                end
                scalar_name = Symbol(scalars_split[2])
                num_components = 1
                if length(scalars_split) >= 4
                    # Some .vtk files have "SCALARS name dataType numComponents"
                    val = tryparse(Int, scalars_split[4])
                    if val !== nothing
                        num_components = val
                    end
                end

                # Next line is typically "LOOKUP_TABLE default"
                if !eof(io)
                    _ = strip(readline(io))
                end

                # Read the scalar values
                total_vals_needed = expected_point_data_count * num_components
                data_accum = Float64[]
                while length(data_accum) < total_vals_needed && !eof(io)
                    vals_line = strip(readline(io))
                    if isempty(vals_line)
                        continue
                    end
                    vals_split = split(vals_line)
                    for v in vals_split
                        parsed_val = tryparse(Float64, v)
                        if parsed_val === nothing
                            throw(ArgumentError("Invalid numeric value in SCALARS data: '$v'"))
                        end
                        push!(data_accum, parsed_val)
                    end
                end

                if length(data_accum) != total_vals_needed
                    throw(ArgumentError("Did not read the expected number of scalar values for '$scalar_name'."))
                end

                if num_components > 1
                    # Reshape into (num_points × num_components)
                    point_data[scalar_name] = reshape(data_accum, (num_components, expected_point_data_count))'
                else
                    point_data[scalar_name] = data_accum
                end

            # --- FIELD blocks ---
            elseif in_point_data && startswith(line, "FIELD")
                # Format: "FIELD FieldData num_fields"
                parts = split(line)
                if length(parts) < 3
                    throw(ArgumentError("Invalid FIELD line: '$line'"))
                end
                fields_to_read = parse(Int, parts[3])

                # Read each field definition
                while fields_to_read > 0 && !eof(io)
                    field_line = strip(readline(io))
                    if isempty(field_line)
                        continue
                    end
                    field_parts = split(field_line)
                    if length(field_parts) < 4
                        throw(ArgumentError("Invalid field definition line: '$field_line'"))
                    end
                    # e.g. "id 1 50000 int"
                    current_field_name = Symbol(field_parts[1])
                    current_field_components = parse(Int, field_parts[2])
                    current_field_points = parse(Int, field_parts[3])
                    # ignore data type
                    total_field_vals = current_field_components * current_field_points
                    collected_vals = Float64[]

                    # Read until we have all values
                    while length(collected_vals) < total_field_vals && !eof(io)
                        val_line = strip(readline(io))
                        if isempty(val_line)
                            continue
                        end
                        for val_str in split(val_line)
                            parsed_val = tryparse(Float64, val_str)
                            if parsed_val === nothing
                                throw(ArgumentError("Invalid numeric value in FIELD '$current_field_name': '$val_str'"))
                            end
                            push!(collected_vals, parsed_val)
                        end
                    end

                    if length(collected_vals) != total_field_vals
                        throw(ArgumentError("Did not read expected number of values for FIELD '$current_field_name'."))
                    end

                    # Store
                    if current_field_components > 1
                        point_data[current_field_name] = reshape(
                            collected_vals, (current_field_components, current_field_points)
                        )'
                    else
                        point_data[current_field_name] = collected_vals
                    end

                    fields_to_read -= 1
                end
            else
                # Skip everything else within POINT_DATA
                continue
            end
        end
    end

    # Reshape the points array into an N×3 matrix correctly
    N = div(length(points_accum), 3)
    points = reshape(points_accum, (3, N))'  # Transpose to get N×3

    return Dict(
        :points => points,
        :point_data => point_data
    )
end


"""
    get_mesh_bounds(mesh_file::Dict)

Computes the axis-aligned bounding box of a mesh based on its point coordinates.

# Arguments
- `mesh_file::Dict`: Dictionary containing mesh data, as produced by `read_vtk_file`. 
  It must include the key `:points`, which should be an N×3 matrix of point coordinates.

# Returns
A vector of 6 numbers in the form `[x_min, x_max, y_min, y_max, z_min, z_max]` representing 
the minimum and maximum bounds of the mesh along the x, y, and z axes respectively.

# Raises
- `ErrorException`: If the mesh file cannot be read, if the `:points` key is missing, 
  or if the points array is not in the expected N×3 format.
"""
function get_mesh_bounds(mesh_file::String)
    # Attempt to read the VTK file, and throw an error if it fails.
    mesh_data = try
        read_vtk_file(mesh_file)
    catch err
        error("Failed to read mesh file: $(err)")
    end

    # Ensure that the mesh_data contains the :points key.
    if !haskey(mesh_data, :points)
        error("Mesh data does not contain a ':points' field.")
    end

    # Extract the points array once.
    points = mesh_data[:points]

    # Validate that the points array is a 2D matrix with 3 columns (nx3).
    if ndims(points) != 2 || size(points, 2) != 3
        error("The ':points' array must be an nx3 matrix, but got an array with size $(size(points)).")
    end

    # Compute the bounds for each coordinate (x, y, z) by iterating over columns.
    bounds = [val for col in 1:3 for val in (minimum(points[:, col]), maximum(points[:, col]))]

    # bounds is returned as [x_min, x_max, y_min, y_max, z_min, z_max]
    return bounds
end


"""
    split_data(data::Dict{Symbol, Any}; split_by::Symbol = :x, value1=nothing, value2=nothing, tolerance=1e-6)

Determines a splitting of the data by returning two lists of point IDs (from `data[:point_data][:id]`)
that correspond to two subsets of the data. This function is intended to be run once at the beginning
of a study.

# Parameters
- `data::Dict{Symbol, Any}`: A dataset containing `:points` and `:point_data`.
- `split_by::Symbol`: The characteristic to split on. Acceptable values include:
  - Cartesian coordinates: `:x`, `:y`, or `:z` (which are taken from the appropriate column of `data[:points]`)
  - Cylindrical coordinates: `:r` or `:theta` (obtained from `retrieve_coordinates` and `convert_to_cylindrical`)
  - Particle properties: e.g. `:radius` or `:type` (taken from `data[:point_data]`)
- `value1` and `value2`: For splitting by particle properties, the target values for each subset.
  If either is not provided, the split will default to using the median value.
- `tolerance::Real`: A tolerance factor used when comparing against `value1` and `value2`.

# Returns
A tuple `(data_1_ids, data_2_ids)` where each is a vector of point IDs corresponding to the
two split subsets.

# Raises
- An error if the input data does not contain required keys.
- An error if the splitting results in an incomplete allocation (e.g. one subset gets all or none of the points).
"""
function split_data(data::Dict{Symbol, Any}; split_by::Symbol = :x, value1=nothing, value2=nothing, tolerance=1e-6)
    # Check that data has required keys.
    for key in (:points, :point_data)
        if !haskey(data, key)
            error("Input data must contain key: $key")
        end
    end
    if !haskey(data[:point_data], :id)
        error("point_data has no 'id' field")
    end

    # For splitting by particle properties, ensure the key exists (unless splitting spatially)
    if split_by ∉ (:r, :theta, :x, :y, :z) && !haskey(data[:point_data], split_by)
        error("point_data does not contain the key: $split_by")
    end

    # Determine the splitting values.
    xyz_symbols = [:x, :y, :z]
    if split_by in xyz_symbols
        # For Cartesian coordinates, get the corresponding column from :points.
        axis_index = findfirst(isequal(split_by), xyz_symbols)
        split_values = data[:points][:, axis_index]
    elseif split_by in (:r, :theta)
        # Convert Cartesian to cylindrical coordinates.
        x_data, y_data, z_data, _ = retrieve_coordinates(data)
        r_data, theta_data = convert_to_cylindrical(x_data, y_data)
        split_values = (split_by == :r) ? r_data : theta_data
    elseif split_by in (:radius, :type)
        split_values = data[:point_data][split_by]
    else
        error("Invalid split_by argument. Use :x, :y, :z, :r, :theta, :radius, or :type.")
    end

    # Decide on splitting strategy.
    if split_by in (:x, :y, :z, :r, :theta)
        # For spatial coordinates, split at the median.
        median_val = median(split_values)
        mask1 = split_values .< median_val
        mask2 = split_values .>= median_val
    elseif split_by in (:radius, :type)
        if value1 === nothing || value2 === nothing
            println("Warning: Not enough target values provided for $split_by; using median split.")
            median_val = median(split_values)
            mask1 = split_values .< median_val
            mask2 = split_values .>= median_val
        else
            rel_tolerance = tolerance * abs(value1)
            mask1 = abs.(split_values .- value1) .< rel_tolerance
            mask2 = abs.(split_values .- value2) .< rel_tolerance
        end
    end

    # Verify that every point is allocated.
    total_points = length(data[:points][:, 1])
    n1 = count(mask1)
    n2 = count(mask2)
    if n1 + n2 < total_points
        error("Incomplete splitting: some points were not allocated (data_1: $n1, data_2: $n2, total: $total_points).")
    elseif n1 == total_points
        error("Incomplete splitting: all data assigned to subset 1 ($split_by, $value1, $value2)")
    elseif n2 == total_points
        error("Incomplete splitting: all data assigned to subset 2 ($split_by, $value1, $value2)")
    end

    # Return only the ID lists, converting them to integers.
    ids = data[:point_data][:id]
    data_1_ids = Set(round.(Int, ids[mask1]))
    data_2_ids = Set(round.(Int, ids[mask2]))
    return data_1_ids, data_2_ids
end


"""
    match_split_data(data::Dict, data_1_ids::Vector{Int}, data_2_ids::Vector{Int})

Given a dataset and two lists of point IDs, this function partitions the data into two subsets.
This is intended for use on subsequent files (after the initial study split).

# Parameters
- `data::Dict`: A dataset containing `:points` and `:point_data`.
- `data_1_ids::Vector{Int}`: The IDs corresponding to the first subset (obtained from `split_data`).
- `data_2_ids::Vector{Int}`: The IDs corresponding to the second subset.

# Returns
A tuple `(data_1, data_2)` where each is a subset of `data` (structured as a dictionary) that
contains only the points with matching IDs.
"""
function match_split_data(data::Dict, data_1_ids::Set{Int}, data_2_ids::Set{Int})
    # Get the complete list of IDs from the current dataset.
    ids = data[:point_data][:id]
    # Create boolean masks based on membership in the provided ID lists.
    mask1 = [id in data_1_ids for id in ids]
    mask2 = [id in data_2_ids for id in ids]
    # Extract the subsets using the helper function.
    data_1 = extract_points(data, mask1)
    data_2 = extract_points(data, mask2)
    return data_1, data_2
end



"""
    extract_points(data::Dict{Symbol, Any}, mask::Union{BitVector, AbstractVector{Bool}})

Extracts a subset of points and their associated data based on the provided mask.

# Parameters
- `data::Dict{Symbol, Any}`: The dataset containing `:points` and `:point_data`.
- `mask::Union{BitVector, AbstractVector{Bool}}`: A boolean array where `true` indicates the points to be extracted.

# Returns
- `subset::Dict{Symbol, Any}`: A dictionary containing the extracted `:points` and `:point_data`.
"""
function extract_points(data::Dict{Symbol, Any}, mask::Union{BitVector, AbstractVector{Bool}})
    # Validate inputs
    num_points = size(data[:points], 1)
    if length(mask) != num_points
        throw(ArgumentError("Length of mask ($length(mask)) does not match number of points ($num_points)."))
    end

    # Extract points
    extracted_points = data[:points][mask, :]

    # Extract point data
    extracted_point_data = Dict{Symbol, Any}()
    for (key, value) in data[:point_data]
        if isa(value, AbstractVector)
            # If the data is a vector, extract using mask directly to preserve it as a vector
            extracted_point_data[key] = value[mask]
        elseif isa(value, AbstractMatrix) && size(value, 1) == num_points
            # If the data is a matrix, extract rows using mask to preserve the matrix structure
            extracted_point_data[key] = value[mask, :]
        else
            throw(ArgumentError("Point data for '$key' does not match number of points or is of unsupported type."))
        end
    end

    return Dict(
        :points => extracted_points,
        :point_data => extracted_point_data
    )
end


"""
    retrieve_coordinates(data::Dict)

Extracts x, y, z coordinates and radii from the dataset.

# Arguments
- `data::Dict`: The data structure returned by `read_vtk_file`.

# Returns
A tuple with:
- `x_data`: Array of x-coordinates.
- `y_data`: Array of y-coordinates.
- `z_data`: Array of z-coordinates.
- `radii`: Array of radii (extracted from `point_data[:radius]`).

# Raises
- `KeyError`: If the `radius` attribute is not found in `point_data`.
"""
function retrieve_coordinates(data::Dict)
    # Extract points from the dataset
    points = data[:points]
    if size(points, 2) != 3
        throw(ArgumentError("The points array must have three columns (x, y, z coordinates)."))
    end

    x_data = points[:, 1]  # x-coordinates
    y_data = points[:, 2]  # y-coordinates
    z_data = points[:, 3]  # z-coordinates

    # Extract radii from point_data
    if haskey(data[:point_data], :radius)
        radii = data[:point_data][:radius]
    else
        throw(KeyError("The dataset does not contain the 'radius' attribute."))
    end

    return x_data, y_data, z_data, radii
end

end # module IO
