# io.jl
# This module contains the two functions required to read vtk files and
# retrieve coordinate data from them

module IO

export read_vtk_file, retrieve_coordinates, extract_points




"""
    read_vtk_file(file::String)

Reads a legacy VTK file (POLYDATA, ASCII) and extracts point coordinates and any point data 
(only SCALARS or FIELD sections). Everything else between `POINTS` and `POINT_DATA` is ignored.

# Arguments
- `file::String`: Path to the `.vtk` file.

# Returns
A dictionary containing:
- `:points`: N×3 matrix of point coordinates.
- `:point_data`: Dictionary of attributes (e.g. scalars, fields) associated with each point.

# Raises
- `ArgumentError`: If the file does not exist, if it's not ASCII/POLYDATA, 
  or if the data sections are invalid.
"""
function read_vtk_file(file::String)
    # Quick check on file existence
    if !isfile(file)
        throw(ArgumentError("The file '$file' does not exist. Please provide a valid path."))
    end

    # We'll store points as a flat Float64 array before reshaping
    points_accum = Float64[]
    point_data = Dict{Symbol,Any}()

    # Keep track of whether we're inside POINT_DATA
    in_point_data = false
    expected_point_data_count = 0

    # For reading FIELD data
    fields_to_read = 0
    remaining_field_components = 0
    current_field_name = nothing
    current_field_components = 0
    current_field_points = 0
    current_field_values = Float64[]

    open(file, "r") do io
        # --- Header lines ---
        header_line1 = readline(io)  # e.g. "# vtk DataFile Version 5.1"
        header_line2 = readline(io)  # e.g. "Generated by X"
        format_line  = strip(readline(io))  # "ASCII" or "BINARY"
        dataset_line = strip(readline(io))  # e.g. "DATASET POLYDATA"

        # Check format
        if format_line != "ASCII"
            throw(ArgumentError("Only ASCII format is supported. Found '$format_line' instead."))
        end
        ds_split = split(dataset_line)
        if length(ds_split) < 2 || ds_split[1] != "DATASET" || ds_split[2] != "POLYDATA"
            throw(ArgumentError("Only 'DATASET POLYDATA' is supported. Found '$dataset_line' instead."))
        end

        # --- Step 1: read POINTS section ---
        # We search for a line beginning with "POINTS"
        num_points = 0
        points_parsed = false
        while !eof(io) && !points_parsed
            line = strip(readline(io))
            if isempty(line)
                continue
            end

            # If we find "POINTS", parse its values
            if startswith(line, "POINTS")
                parts = split(line)
                if length(parts) < 3
                    throw(ArgumentError("Invalid 'POINTS' line: '$line'"))
                end
                num_points = parse(Int, parts[2])
                # e.g. "float" or "double" is parts[3], ignored here

                total_needed = 3 * num_points
                while length(points_accum) < total_needed
                    if eof(io)
                        println("Error in file: $file")
                        throw(ArgumentError("Unexpected end of file while reading POINTS data."))
                    end
                    coords_line = strip(readline(io))
                    if isempty(coords_line)
                        continue
                    end
                    coords = split(coords_line)
                    for c in coords
                        val = tryparse(Float64, c)
                        if val === nothing
                            println("Error in file: $file")
                            throw(ArgumentError("Invalid numeric value in POINTS section: '$c'"))
                        end
                        push!(points_accum, val)
                    end
                end

                # We've parsed the correct number of coordinates, set a flag
                points_parsed = true
            end
        end

        if length(points_accum) != 3 * num_points
            throw(ArgumentError("Number of coordinate values read does not match '3 * num_points'."))
        end

        # --- Step 2: ignore lines until we hit "POINT_DATA" ---
        while !eof(io)
            # Peek at the line without losing it
            pos = position(io)
            line = strip(readline(io))
            if startswith(line, "POINT_DATA")
                # Seek back so we can reprocess properly
                seek(io, pos)
                break
            end
        end

        # --- Step 3: read POINT_DATA ---
        while !eof(io)
            line = strip(readline(io))
            if isempty(line)
                continue
            end

            # Found POINT_DATA
            if startswith(line, "POINT_DATA")
                parts = split(line)
                if length(parts) < 2
                    throw(ArgumentError("Malformed 'POINT_DATA' line: '$line'"))
                end
                in_point_data = true
                expected_point_data_count = parse(Int, parts[2])  # Corrected index

            # --- SCALARS blocks ---
            elseif in_point_data && startswith(line, "SCALARS")
                scalars_split = split(line)
                if length(scalars_split) < 3
                    throw(ArgumentError("Invalid SCALARS definition: '$line'"))
                end
                scalar_name = Symbol(scalars_split[2])
                num_components = 1
                if length(scalars_split) >= 4
                    # Some .vtk files have "SCALARS name dataType numComponents"
                    val = tryparse(Int, scalars_split[4])
                    if val !== nothing
                        num_components = val
                    end
                end

                # Next line is typically "LOOKUP_TABLE default"
                if !eof(io)
                    _ = strip(readline(io))
                end

                # Read the scalar values
                total_vals_needed = expected_point_data_count * num_components
                data_accum = Float64[]
                while length(data_accum) < total_vals_needed && !eof(io)
                    vals_line = strip(readline(io))
                    if isempty(vals_line)
                        continue
                    end
                    vals_split = split(vals_line)
                    for v in vals_split
                        parsed_val = tryparse(Float64, v)
                        if parsed_val === nothing
                            throw(ArgumentError("Invalid numeric value in SCALARS data: '$v'"))
                        end
                        push!(data_accum, parsed_val)
                    end
                end

                if length(data_accum) != total_vals_needed
                    throw(ArgumentError("Did not read the expected number of scalar values for '$scalar_name'."))
                end

                if num_components > 1
                    # Reshape into (num_points × num_components)
                    point_data[scalar_name] = reshape(data_accum, (num_components, expected_point_data_count))'
                else
                    point_data[scalar_name] = data_accum
                end

            # --- FIELD blocks ---
            elseif in_point_data && startswith(line, "FIELD")
                # Format: "FIELD FieldData num_fields"
                parts = split(line)
                if length(parts) < 3
                    throw(ArgumentError("Invalid FIELD line: '$line'"))
                end
                fields_to_read = parse(Int, parts[3])

                # Read each field definition
                while fields_to_read > 0 && !eof(io)
                    field_line = strip(readline(io))
                    if isempty(field_line)
                        continue
                    end
                    field_parts = split(field_line)
                    if length(field_parts) < 4
                        throw(ArgumentError("Invalid field definition line: '$field_line'"))
                    end
                    # e.g. "id 1 50000 int"
                    current_field_name = Symbol(field_parts[1])
                    current_field_components = parse(Int, field_parts[2])
                    current_field_points = parse(Int, field_parts[3])
                    # ignore data type
                    total_field_vals = current_field_components * current_field_points
                    collected_vals = Float64[]

                    # Read until we have all values
                    while length(collected_vals) < total_field_vals && !eof(io)
                        val_line = strip(readline(io))
                        if isempty(val_line)
                            continue
                        end
                        for val_str in split(val_line)
                            parsed_val = tryparse(Float64, val_str)
                            if parsed_val === nothing
                                throw(ArgumentError("Invalid numeric value in FIELD '$current_field_name': '$val_str'"))
                            end
                            push!(collected_vals, parsed_val)
                        end
                    end

                    if length(collected_vals) != total_field_vals
                        throw(ArgumentError("Did not read expected number of values for FIELD '$current_field_name'."))
                    end

                    # Store
                    if current_field_components > 1
                        point_data[current_field_name] = reshape(
                            collected_vals, (current_field_components, current_field_points)
                        )'
                    else
                        point_data[current_field_name] = collected_vals
                    end

                    fields_to_read -= 1
                end
            else
                # Skip everything else within POINT_DATA
                continue
            end
        end
    end

    # Reshape the points array into an N×3 matrix correctly
    N = div(length(points_accum), 3)
    points = reshape(points_accum, (3, N))'  # Transpose to get N×3

    return Dict(
        :points => points,
        :point_data => point_data
    )
end


"""
    extract_points(data::Dict{Symbol, Any}, mask::Union{BitVector, AbstractVector{Bool}})

Extracts a subset of points and their associated data based on the provided mask.

# Parameters
- `data::Dict{Symbol, Any}`: The dataset containing `:points` and `:point_data`.
- `mask::Union{BitVector, AbstractVector{Bool}}`: A boolean array where `true` indicates the points to be extracted.

# Returns
- `subset::Dict{Symbol, Any}`: A dictionary containing the extracted `:points` and `:point_data`.
"""
function extract_points(data::Dict{Symbol, Any}, mask::Union{BitVector, AbstractVector{Bool}})
    # Validate inputs
    num_points = size(data[:points], 1)
    if length(mask) != num_points
        throw(ArgumentError("Length of mask ($length(mask)) does not match number of points ($num_points)."))
    end

    # Extract points
    extracted_points = data[:points][mask, :]

    # Extract point data
    extracted_point_data = Dict{Symbol, Any}()
    for (key, value) in data[:point_data]
        if isa(value, AbstractVector)
            # If the data is a vector, extract using mask directly to preserve it as a vector
            extracted_point_data[key] = value[mask]
        elseif isa(value, AbstractMatrix) && size(value, 1) == num_points
            # If the data is a matrix, extract rows using mask to preserve the matrix structure
            extracted_point_data[key] = value[mask, :]
        else
            throw(ArgumentError("Point data for '$key' does not match number of points or is of unsupported type."))
        end
    end

    return Dict(
        :points => extracted_points,
        :point_data => extracted_point_data
    )
end


"""
    retrieve_coordinates(data::Dict)

Extracts x, y, z coordinates and radii from the dataset.

# Arguments
- `data::Dict`: The data structure returned by `read_vtk_file`.

# Returns
A tuple with:
- `x_data`: Array of x-coordinates.
- `y_data`: Array of y-coordinates.
- `z_data`: Array of z-coordinates.
- `radii`: Array of radii (extracted from `point_data[:radius]`).

# Raises
- `KeyError`: If the `radius` attribute is not found in `point_data`.
"""
function retrieve_coordinates(data::Dict)
    # Extract points from the dataset
    points = data[:points]
    if size(points, 2) != 3
        throw(ArgumentError("The points array must have three columns (x, y, z coordinates)."))
    end

    x_data = points[:, 1]  # x-coordinates
    y_data = points[:, 2]  # y-coordinates
    z_data = points[:, 3]  # z-coordinates

    # Extract radii from point_data
    if haskey(data[:point_data], :radius)
        radii = data[:point_data][:radius]
    else
        throw(KeyError("The dataset does not contain the 'radius' attribute."))
    end

    return x_data, y_data, z_data, radii
end

end # module IO
